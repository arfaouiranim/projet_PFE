# -*- coding: utf-8 -*-
"""code PFE step1 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MyImaqI-HYYVr5SdEEdBc1rz5qJEa622
"""

import pandas as pd
from google.colab import drive

# Monter Google Drive pour accéder aux fichiers
drive.mount('/content/drive')

# Chemin du fichier CSV sur Google Drive
file_path = "/content/drive/MyDrive/stage PFE /miRNAfinal.csv"  # Remplacez par le chemin réel
# Chemins des fichiers de sortie sur Google Drive
output_low_identity_path = "/content/drive/MyDrive/stage PFE /low_identity2.txt"  # Remplacez par le chemin réel
output_high_identity_path = "/content/drive/MyDrive/stage PFE /high_identity2.txt"

# Lecture du fichier CSV
df = pd.read_csv(file_path)

# Implémentation de l'algorithme de Needleman-Wunsch
def needleman_wunsch(seq1, seq2, match_score=1, gap_cost=-1, mismatch_cost=-1):
    n = len(seq1)
    m = len(seq2)

    # Initialisation de la matrice de score
    score_matrix = [[0 for _ in range(m+1)] for _ in range(n+1)]

    # Remplissage de la première ligne et de la première colonne
    for i in range(1, n+1):
        score_matrix[i][0] = i * gap_cost
    for j in range(1, m+1):
        score_matrix[0][j] = j * gap_cost

    # Remplissage de la matrice de score
    for i in range(1, n+1):
        for j in range(1, m+1):
            match = score_matrix[i-1][j-1] + (match_score if seq1[i-1] == seq2[j-1] else mismatch_cost)
            delete = score_matrix[i-1][j] + gap_cost
            insert = score_matrix[i][j-1] + gap_cost
            score_matrix[i][j] = max(match, delete, insert)

    # Calcul du score d'alignement
    score = score_matrix[n][m]

    # Calcul de l'identité
    identity = sum(1 for a, b in zip(seq1, seq2) if a == b) / max(len(seq1), len(seq2)) * 100

    return score, identity, seq1, seq2

# Fonction pour écrire les résultats dans un fichier
def write_results(file, pair, species1, species2, score, identity, seq1, seq2):
    file.write(f"Paire: {pair}\n")
    file.write(f"Espèce {pair.split(' vs ')[0]}: {species1}\n")
    file.write(f"Espèce {pair.split(' vs ')[1]}: {species2}\n")
    file.write(f"Score: {score}\n")
    file.write(f"Identité: {identity:.2f}%\n")
    file.write(f"Alignement {pair.split(' vs ')[0]}:\n{seq1}\n")
    file.write(f"Alignement {pair.split(' vs ')[1]}:\n{seq2}\n")
    file.write("\n")


# Ouverture des fichiers de sortie
with open("low_identity2.txt", "w") as file_low, open("high_identity2.txt", "w") as file_high:
    # Parcours de toutes les paires de séquences
    for i in range(len(df)):
        for j in range(i+1, len(df)):
            seq1 = df.loc[i, "Sequence"]
            seq2 = df.loc[j, "Sequence"]
            name1 = df.loc[i, "Name"]
            name2 = df.loc[j, "Name"]
            species1 = df.loc[i, "Species"]
            species2 = df.loc[j, "Species"]

            # Alignement des séquences
            score, identity, aligned_seq1, aligned_seq2 = needleman_wunsch(seq1, seq2)

            # Écriture des résultats dans les fichiers appropriés
            pair = f"{name1} vs {name2}"
            if identity == 100:
                write_results(file_high, pair, species1, species2, score, identity, aligned_seq1, aligned_seq2)
            elif identity < 15:
                write_results(file_low, pair, species1, species2, score, identity, aligned_seq1, aligned_seq2)

print("Alignements terminés et résultats écrits dans les fichiers low_identity2.txt et high_identity2.txt.")
print(f"- {output_low_identity_path}")
print(f"- {output_high_identity_path}")