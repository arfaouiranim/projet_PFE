# -*- coding: utf-8 -*-
"""code PFE step3 hight.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CHPmbNbDekFhJITu0pdYt4vSwyHmvt4x
"""

# Installer ViennaRNA
!pip install ViennaRNA

from google.colab import drive
import pandas as pd
import RNA

# Monter Google Drive
drive.mount('/content/drive')

# Charger le CSV existant
csv_path = "/content/drive/MyDrive/stage PFE /high_identity0.csv"
df = pd.read_csv(csv_path)

print(df.columns)

# Fonction pour calculer le GC%
def calculate_gc(seq):
    gc = seq.count('G') + seq.count('C')
    return round((gc / len(seq)) * 100, 2) if seq else 0

# Fonction pour le GC% de la graine (positions 2-8)
def calculate_seed_gc(seq):
    seed = seq[1:8] if len(seq) >= 8 else ''
    return calculate_gc(seed) if seed else 0



# Configuration spécifique pour les plantes
PLANT_TEMP = 25.0  # Température standard pour les plantes
MIN_LENGTH = 18    # Longueur minimale typique des miRNA végétaux

def calculate_deltaG_plant(seq):
    """Calcule le deltaG avec paramètres adaptés aux plantes"""
    try:
        # Nettoyage et validation de la séquence
        clean_seq = seq.upper().replace('T', 'U').replace('-', '')

        # Filtrage des séquences non valides
        if len(clean_seq) < MIN_LENGTH or any(c not in 'ACGU' for c in clean_seq):
            return None

        # Configuration du modèle thermodynamique
        md = RNA.md()
        md.temperature = PLANT_TEMP    # Adapté aux conditions végétales
        md.dangles = 2                # Modèle de dangles amélioré
        md.noLP = 1                   # Pas de paires isolées
        md.logML = 1                   # Correction du volume exclu

        # Création de l'objet de calcul
        fc = RNA.fold_compound(clean_seq, md)

        # Calcul de la structure optimale
        structure, mfe = fc.mfe()

        # Validation du résultat
        if not -11.0 <= mfe <= -0.1:  # Plage attendue pour les végétaux
            return None

        return round(mfe, 2)

    except Exception as e:
        print(f"Erreur sur {seq[:15]}...: {str(e)}")
        return None

# Application au DataFrame
df['Thermodynamic stability (deltaG)'] = df['séquence de miRNA'].apply(calculate_deltaG_plant)

# Filtrage des résultats invalides
df = df[df['Thermodynamic stability (deltaG)'].notna()]



print("Calcul deltaG végétal réussi avec ViennaRNA!")
print(f"{len(df)} séquences valides (-11 ≤ deltaG ≤ -0.1)")


df['miRNA length'] = df['séquence de miRNA'].apply(len)
df['GC content (%)'] = df['séquence de miRNA'].apply(calculate_gc)
df['Seed GC content (positions 2-8)'] = df['séquence de miRNA'].apply(calculate_seed_gc)
df['Thermodynamic stability (deltaG)'] = df['séquence de miRNA'].apply(calculate_deltaG_plant)


# Nouvel ordre des colonnes
new_order = [
    'code de miRNA',
    'nombre of species',
    'séquence de miRNA',
    'miRNA length',
    'GC content (%)',
    'Seed GC content (positions 2-8)',
    'Thermodynamic stability (deltaG)',  # Nom modifié
    'espèce'
]

# Sauvegarde
df[new_order].to_csv(csv_path, index=False)

print("CSV update completed successfully!")
print(f"New columns added: {list(new_order[3:-1])}")

def calculate_overall_pairing(seq):
    """Calcule la probabilité d'appariement globale d'une séquence d'ARN (normalisée entre 0 et 1)"""
    try:
        # Nettoyage et validation
        clean_seq = seq.upper().replace('T', 'U').replace('-', '')
        valid_chars = {'A', 'C', 'G', 'U'}

        if not all(c in valid_chars for c in clean_seq):
            return None

        if len(clean_seq) < 2:
            return None

        # Calcul de la fonction de partition
        fc = RNA.fold_compound(clean_seq)
        fc.pf()  # Compute partition function
        bpp_matrix = fc.bpp()  # Get base pair probability matrix

        # Calcul de la probabilité d'appariement globale
        total_prob = 0.0
        for i in range(len(clean_seq)):
            for j in range(i + 1, len(clean_seq)):
                total_prob += bpp_matrix[i][j]

        # Normalisation pour obtenir une probabilité moyenne par paire
        num_pairs = len(clean_seq) * (len(clean_seq) - 1) / 2  # Nombre de paires possibles
        avg_prob = total_prob / num_pairs if num_pairs > 0 else 0  # Probabilité moyenne par paire

        return round(avg_prob, 3)

    except Exception as e:
        print(f"Erreur avec {seq[:15]}...: {str(e)}")
        return None
# Ajouter la nouvelle colonne
df['overall_pairing_probability'] = df['séquence de miRNA'].apply(calculate_overall_pairing)

# Réorganiser les colonnes - Vérifier et corriger les noms de colonnes
cols = [
    'code de miRNA',
    'nombre of species',
    'séquence de miRNA',
    'miRNA length',  # Vérifier ce nom de colonne dans votre CSV
    'GC content (%)',
    'Seed GC content (positions 2-8)',  # Vérifier ce nom de colonne dans votre CSV
    'Thermodynamic stability (deltaG)',  # Vérifier ce nom de colonne dans votre CSV
    'overall_pairing_probability',
    'espèce'
]

# Afficher les colonnes du DataFrame pour vérification
print(df.columns)

# Sauvegarder
df[cols].to_csv(csv_path, index=False)

print("Colonne de probabilité globale ajoutée avec succès !")
print("Statistiques descriptives :")
print(df['overall_pairing_probability'].describe())

def calculate_z_curve(seq):
    """Calcule les paramètres Z-curve pour chaque position de la séquence"""
    try:
        # Nettoyage comme dans calculate_overall_pairing
        clean_seq = seq.upper().replace('T', 'U').replace('-', '')
        valid_chars = {'A', 'C', 'G', 'U'}

        if not all(c in valid_chars for c in clean_seq):
            return {}

        x_total = 0
        y_total = 0
        z_total = 0
        z_params = {}

        for idx, nt in enumerate(clean_seq, 1):
            # Calcul des composantes pour chaque nucléotide
            if nt == 'A':
                dx, dy, dz = 1, 1, 1
            elif nt == 'C':
                dx, dy, dz = -1, 1, -1
            elif nt == 'G':
                dx, dy, dz = 1, -1, -1
            elif nt == 'U':
                dx, dy, dz = -1, -1, 1
            else:
                dx, dy, dz = 0, 0, 0

            # Mise à jour des sommes cumulatives
            x_total += dx
            y_total += dy
            z_total += dz

            # Ajout des valeurs pour cette position
            z_params[f'x_{idx}'] = x_total
            z_params[f'y_{idx}'] = y_total
            z_params[f'z_{idx}'] = z_total

        return z_params

    except Exception as e:
        print(f"Erreur Z-curve avec {seq[:15]}...: {str(e)}")
        return {}

# Ajouter la colonne de probabilité globale
df['overall_pairing_probability'] = df['séquence de miRNA'].apply(calculate_overall_pairing)

# Générer les colonnes Z-curve
z_curve_data = df['séquence de miRNA'].apply(calculate_z_curve)
z_curve_df = pd.DataFrame(z_curve_data.tolist())

# Fusionner avec le DataFrame principal
df = pd.concat([df, z_curve_df], axis=1)

# Sauvegarder toutes les colonnes
df.to_csv(csv_path, index=False)

print("Colonnes Z-curve ajoutées avec succès !")
print(f"Nombre total de colonnes : {len(df.columns)}")
print("Exemple de nouvelles colonnes :", df.columns[-6:].tolist())

